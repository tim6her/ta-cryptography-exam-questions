<!DOCTYPE html>
<html  dir="ltr">

    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Cryptography – Exam Questions</title>
        <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">
        <link rel="apple-touch-icon-precomposed" href="images/apple-touch-icon.png">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/uikit/2.26.4/css/uikit.gradient.css">

        <link rel="stylesheet" href="style.css">
        <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />
        <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
        <script src="uikit.js"></script>
        <script src="scripts.js"></script>
        <script src="jquery.sticky-kit.js "></script>

        <meta name="generator" content="pandoc-uikit" />
                <meta name="author" content="Tim Herbstrith" />
                        <meta name="date" content="2020-01-01" />
                <title>Cryptography – Exam Questions</title>
        <style type="text/css">code{white-space: pre;}</style>
                                        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
                                        <script>document.addEventListener("DOMContentLoaded", function () {
                                         var mathElements = document.getElementsByClassName("math");
                                         for (var i = 0; i < mathElements.length; i++) {
                                          var texText = mathElements[i].firstChild;
                                          if (mathElements[i].tagName == "SPAN") {
                                           katex.render(texText.data, mathElements[i], {
                                            displayMode: mathElements[i].classList.contains('display'),
                                            throwOnError: false,
                                            fleqn: false
                                           });
                                        }}});
                                        </script>
                                        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
                    </head>

    <body>


        <div class="uk-container uk-container-center uk-margin-top uk-margin-large-bottom">

                        <div class="uk-grid" data-uk-grid-margin>
                <div class="uk-width-1-1">
                    <h1 class="uk-heading-large">Cryptography – Exam Questions</h1>
                                        <p class="uk-text-large">
                                        Tim Herbstrith,
                                                            2020
                                        </p>
                </div>
            </div>
            
            <div class="uk-grid" data-uk-grid-margin >
                <div class="uk-width-medium-1-4">
                    <div class="uk-overflow-container" data-uk-sticky="{top:25,media: 768}">
                        <div class="uk-panel uk-panel-box menu-begin" >

                                                        <ul>
                                                        <li><a href="#cryptography-principles-basic-model-for-secrecy-cryptosystem-for-secrecy"><span class="toc-section-number">1</span> Cryptography principles / Basic model for secrecy / Cryptosystem for secrecy</a></li>
                                                        <li><a href="#attacks-on-encryption-algorithms"><span class="toc-section-number">2</span> Attacks on encryption algorithms</a></li>
                                                        <li><a href="#sec:symmetric-cs"><span class="toc-section-number">3</span> Examples of symmetric cryptosystems</a></li>
                                                        <li><a href="#computational-complexity"><span class="toc-section-number">4</span> Computational complexity</a></li>
                                                        <li><a href="#three-types-of-security"><span class="toc-section-number">5</span> Three types of security</a></li>
                                                        <li><a href="#sec:rsa"><span class="toc-section-number">6</span> RSA cryptosystem</a></li>
                                                        <li><a href="#one-way-functions"><span class="toc-section-number">7</span> One-way functions</a></li>
                                                        <li><a href="#hash-functions"><span class="toc-section-number">8</span> Hash functions</a></li>
                                                        <li><a href="#discrete-logarithm-problem"><span class="toc-section-number">9</span> Discrete logarithm problem</a></li>
                                                        <li><a href="#elgamal-cryptosystem"><span class="toc-section-number">10</span> ElGamal cryptosystem</a></li>
                                                        <li><a href="#elliptic-curves"><span class="toc-section-number">11</span> Elliptic curves</a></li>
                                                        <li><a href="#group-structure-on-elliptic-curves"><span class="toc-section-number">12</span> Group structure on elliptic curves</a></li>
                                                        <li><a href="#cayley-bacharachs-theorem"><span class="toc-section-number">13</span> Cayley-Bacharach’s theorem</a></li>
                                                        <li><a href="#associativity"><span class="toc-section-number">14</span> Associativity</a></li>
                                                        <li><a href="#elliptic-curves-over-finite-fields"><span class="toc-section-number">15</span> Elliptic curves over finite fields</a></li>
                                                        <li><a href="#diffie-hellman-key-agreement-protocol"><span class="toc-section-number">16</span> Diffie-Hellman key agreement protocol</a></li>
                                                        <li><a href="#digital-signature-scheme"><span class="toc-section-number">17</span> Digital signature scheme</a></li>
                                                        <li><a href="#sec:dss-with-hashing"><span class="toc-section-number">18</span> DSS with hashing</a></li>
                                                        <li><a href="#dss-and-public-key-cryptosystems"><span class="toc-section-number">19</span> DSS and Public-key cryptosystems</a></li>
                                                        <li><a href="#elgamal-variant-of-dss-definition"><span class="toc-section-number">20</span> ElGamal variant of DSS (Definition)</a></li>
                                                        <li><a href="#elgamal-and-ecdsa-variants-of-dss"><span class="toc-section-number">21</span> ElGamal and ECDSA variants of DSS</a></li>
                                                        <li><a href="#digital-currency"><span class="toc-section-number">22</span> Digital currency</a></li>
                                                        <li><a href="#bitcoin-transactions"><span class="toc-section-number">23</span> Bitcoin transactions</a></li>
                                                        <li><a href="#bit-generators"><span class="toc-section-number">24</span> Bit generators</a></li>
                                                        <li><a href="#distinguisher-and-next-bit-predictors"><span class="toc-section-number">25</span> Distinguisher and next bit predictors</a></li>
                                                        <li><a href="#error-correcting-codes-and-expander-graphs"><span class="toc-section-number">26</span> Error-correcting codes and expander graphs</a></li>
                                                        <li><a href="#probabilistic-pidgeonhole-principle"><span class="toc-section-number">27</span> Probabilistic pidgeonhole principle</a></li>
                                                        <li><a href="#attacks-on-cryptosystems-relying-on-structural-weaknesses"><span class="toc-section-number">28</span> Attacks on cryptosystems relying on structural weaknesses</a></li>
                                                        <li><a href="#shanks-algorithm"><span class="toc-section-number">29</span> Shanks algorithm</a></li>
                                                        <li><a href="#todo-s"><span class="toc-section-number">30</span> TODO-s:</a></li>
                                                        </ul>
                            
                        </div>
                        <div class="uk-panel uk-panel-box menu-begin" >

<dl>
  <dt>Downloads</dt>

  <dd><a href="./index.pdf">PDF</a></dd>

  <dd><a href="./index.epub">Epub</a></dd>

</dl>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>

                        </div>
                    </div>
                </div>

                <div class="uk-width-medium-3-4">
<p>All quotes are from <span class="citation" data-cites="Arzhantseva2019">Arzhantseva (<a href="#ref-Arzhantseva2019" role="doc-biblioref">2019</a>)</span>.</p>
<h1 data-number="1" id="cryptography-principles-basic-model-for-secrecy-cryptosystem-for-secrecy" data-number="1"><span class="header-section-number">1</span> Cryptography principles / Basic model for secrecy / Cryptosystem for secrecy</h1>
<blockquote>
<p>Cryptography principles definitions, (non) examples. Basic cryptography concepts (primitive, protocol, cover time, etc.). Basic model for secrecy: (non)-examples. Cryptosystem for secrecy: definition, examples. Symmetric versus asymmetric cryptosystems.</p>
</blockquote>
<h2 data-number="1.1" id="cryptography-principles" data-number="1.1"><span class="header-section-number">1.1</span> Cryptography principles</h2>
<ul>
<li>Confidentiality / secrecy:
<ul>
<li>limit access to information</li>
</ul></li>
<li>Data Integrity
<ul>
<li>data was not altered (intentionally or accidentally)</li>
<li>detection of alteration (not prevention)</li>
</ul></li>
<li>Data origin authentication / message authentication
<ul>
<li>confirms the origin of data with no temporal aspect to the <strong>receiver</strong></li>
<li>not necessarily an immediate source / not when</li>
</ul></li>
<li>Entity authentication
<ul>
<li>a given entity is involved and currently active</li>
<li>e.g. log in at web service</li>
</ul></li>
<li>Non-Repudiation
<ul>
<li>a source of data cannot deny to a <strong>third party</strong> being at the origin</li>
</ul></li>
</ul>
<p>Data origin authentication <span class="math inline">⇒</span> Data integrity</p>
<p>Non-Repudiation <span class="math inline">⇒</span> Data origin authentication</p>
<p>Data origin authentication <span class="math inline">≠</span> Entity authentication</p>
<p>Secrecy <span class="math inline">\nRightarrow</span> Data origin authentication</p>
<h2 data-number="1.2" id="different-cryptographic-concepts" data-number="1.2"><span class="header-section-number">1.2</span> Different cryptographic concepts</h2>
<ul>
<li>Cryptography = <strong>toolkit</strong></li>
<li>Cryptographic <strong>primitive</strong> = a basic tool in this toolkit
<ul>
<li>Examples: Encryption, hash function, MAC (message authentication code), digital signature, etc.</li>
</ul></li>
<li>Cryptographic <strong>algorithm</strong> = Cipher = a specification of a primitive</li>
<li>Cryptographic <strong>protocol</strong> = a way to choose primitives and use them for a security goal</li>
<li>Crypto<strong>system</strong> = implementation of primitives and the infrastructure</li>
</ul>
<h2 data-number="1.3" id="basic-model-of-a-cryptosystem" data-number="1.3"><span class="header-section-number">1.3</span> Basic model of a cryptosystem</h2>
<figure>
<img src="./imgs/basic_model_for_secrecy.png" id="fig:basic_model" alt="" /><figcaption>Figure 1: Basic model of a cryptosystem <span class="citation" data-cites="Martin2012">(Martin <a href="#ref-Martin2012" role="doc-biblioref">2012</a>)</span></figcaption>
</figure>
<p>Fig. <a href="#fig:basic_model">1</a> depicts a sender who wishes to transfer some data to a receiver in such a way that any party intercepting the transmitted data cannot determine the content. <em>The interceptor must not know the decryption key.</em></p>
<p>Secrecy can be provided by (combination of):</p>
<ol type="1">
<li>Cryptography (via encryption)</li>
<li>Steganography (via information hiding)</li>
<li>Access control (via software or hardware)</li>
</ol>
<h2 data-number="1.4" id="definition-of-cryptosystem" data-number="1.4"><span class="header-section-number">1.4</span> Definition of Cryptosystem</h2>
<p><strong>Cryptosystem</strong> is a <span class="math inline">5</span>-tuple <span class="math inline">(\mathcal{P, C, K, E, D})</span> satisfying:</p>
<ul>
<li><span class="math inline">\mathcal{P}</span> is a finite set of possible <strong>plaintexts</strong>;</li>
<li><span class="math inline">\mathcal{C}</span> is a finite set of possible <strong>ciphertexts</strong>;</li>
<li><span class="math inline">\mathcal{K}</span>, the keyspace, is a finite set of possible <strong>keys</strong>;</li>
<li><span class="math inline">\mathcal{E} = \lbrace{E_k : k ∈ \mathcal{K}}\rbrace</span> consists of <strong>encryption functions</strong> <span class="math inline">E_k : \mathcal{P → C}</span>;</li>
<li><span class="math inline">\mathcal{D} = \lbrace{D_k : k ∈ \mathcal{K}}\rbrace</span> consists of <strong>decryption functions</strong> <span class="math inline">D_k : \mathcal{C → P}</span>;</li>
<li>For all <span class="math inline">e ∈ \mathcal{K}</span> there exists <span class="math inline">d ∈ \mathcal{K}</span> such that for all plaintexts <span class="math inline">p ∈ \mathcal{P}</span> we have: <span class="math display">D_d(E_e(p)) = p</span></li>
</ul>
<p>The cryptosystem is</p>
<ul>
<li><strong>symmetric</strong> if <span class="math inline">e = d</span> and</li>
<li><strong>public-key</strong> if <span class="math inline">d</span> cannot be derived from <span class="math inline">e</span> in a computationally feasible way</li>
</ul>
<h2 data-number="1.5" id="cover-time" data-number="1.5"><span class="header-section-number">1.5</span> Cover time</h2>
<p><strong>Cover time</strong> = the time for which a plaintext must be kept secret.</p>
<h1 data-number="2" id="attacks-on-encryption-algorithms" data-number="2"><span class="header-section-number">2</span> Attacks on encryption algorithms</h1>
<blockquote>
<p>Main attacks on encryption algorithms. Passive versus active attacks. Keys: length, size. Brute-force attack: assumptions, estimates on key lengths.</p>
</blockquote>
<h2 data-number="2.1" id="targets-of-attacks" data-number="2.1"><span class="header-section-number">2.1</span> Targets of attacks</h2>
<ul>
<li>A practical method of determining the <strong>decryption key</strong> is found.</li>
<li>A weakness in the encryption algorithm leads to a <strong>plaintext</strong>.</li>
</ul>
<h2 data-number="2.2" id="passive-vs-active-attacks" data-number="2.2"><span class="header-section-number">2.2</span> Passive vs active attacks</h2>
<ul>
<li>The main type of <strong>passive attack</strong> is unauthorised access to data.</li>
<li>An <strong>active attack</strong> involves either data being changed in some way, or a process being conducted on the data.</li>
</ul>
<h2 data-number="2.3" id="key-lengths-and-sizes" data-number="2.3"><span class="header-section-number">2.3</span> Key lengths and sizes</h2>
<ul>
<li><strong>Length</strong> of the key = number of bites it takes to represent the key</li>
<li><strong>Size</strong> of the keyspace = number of possible different decryption keys</li>
</ul>
<h2 data-number="2.4" id="assumptions" data-number="2.4"><span class="header-section-number">2.4</span> Assumptions</h2>
<ul>
<li>All keys from the keyspace are equally likely to be selected</li>
<li>The correct decryption key is identified as soon as it is tested</li>
</ul>
<h2 data-number="2.5" id="estimates-on-key-length" data-number="2.5"><span class="header-section-number">2.5</span> Estimates on key length</h2>
<p>If Size = <span class="math inline">n = 2k</span>, then, on average, one needs <span class="math inline">∼ 2k − 1</span> attempts to find the correct decryption key:</p>
<p><span class="math display">\mathbb{E}[X] = \sum_{i = 1}^n i \frac{1}{n} =
   \frac{n \; (n - 1)}{2} = \frac{2^k + 1}{2} ∼ 2^{k - 1}</span></p>
<h1 data-number="3" id="sec:symmetric-cs" data-number="3"><span class="header-section-number">3</span> Examples of symmetric cryptosystems</h1>
<blockquote>
<p>Examples of symmetric cryptosystems: Caesar and Substitution ciphers. The letter frequency analysis. Monoalphabetic and polyalphabetic cyphers. Vigenère cipher. If the given key of a Vigenère Cipher has repeated letters, does it make it any easier to break?</p>
</blockquote>
<h2 data-number="3.1" id="caeser-cipher" data-number="3.1"><span class="header-section-number">3.1</span> Caeser Cipher</h2>
<p>Replace each alphabet by another alphabet which is ‘shifted’ by some fixed number between 0 and 25. Key = ’secret shift number’. Length=1</p>
<p>Formally, we identify <span class="math inline">\lbrace \mathtt{A, B, C, …, Z} \rbrace \cong ℤ / 26 ℤ</span>. Then <span class="math inline">\mathcal{P} = \lbrace{(a_0, …,a_n) \mid a_i ∈ ℤ / 26 ℤ, n ∈ ℕ}\rbrace</span> and <span class="math display">\begin{aligned}
E_k(a_1, …, a_n) &amp;= (a_0 + k, …, a_n + k)\\
D_k(c_1, …, c_n) &amp;= (c_0 - k, …, c_n - k).
\end{aligned}
</span> (all operations are to be understood <span class="math inline">\mod 26</span>.)</p>
<figure>
<img src="./imgs/caeser.png" id="fig:caeser" alt="" /><figcaption>Figure 2: The Caeser Cipher shifts all letters by a fixed constant <span class="citation" data-cites="CaeserCipher2020">(“Caesar Cipher in Cryptography - Geeksforgeeks” <a href="#ref-CaeserCipher2020" role="doc-biblioref">2020</a>)</span></figcaption>
</figure>
<h2 data-number="3.2" id="simple-substitution-cipher" data-number="3.2"><span class="header-section-number">3.2</span> Simple Substitution Cipher</h2>
<p>Replace each alphabet by another alphabet which is its random permutation. Key = a permutation of 26 letters. Length = 26</p>
<p>Formally, we identify <span class="math inline">\lbrace \mathtt{A, B, C, …, Z} \rbrace \cong ℤ / 26 ℤ</span>. Then <span class="math inline">\mathcal{P} = \lbrace{(a_0, …,a_n) \mid a_i ∈ ℤ / 26 ℤ, n ∈ ℕ}\rbrace</span> and <span class="math display">\begin{aligned}
E_k(a_1, …, a_n) &amp;= (σ(a_0), …, σ(a_n))\\
D_k(c_1, …, c_n) &amp;= (σ^{-1}(c_0), …, σ^{-1}(c_n)),
\end{aligned}</span> where <span class="math inline">σ ∈ Sym(26)</span> is the encryption/decryption key.</p>
<p>Caeser Cipher is special case of Simple Substitution Cipher, where <span class="math inline">σ</span> is a cyclic permutation.</p>
<p>The total key space has size <span class="math inline">26!</span>, which is greater than the number of stars in the universe.</p>
<p>Since every letter is encrypted by a unique letter, SSC is an example of a <strong>monoalphabetic</strong> cipher.</p>
<p>They are easily breakable by <strong>letter frequency analysis</strong>:</p>
<p>If the plaintext is known to be written in a specific language, we can compare letter frequencies of the language with the letter frequencies of the cipher text.</p>
<p>Thus, <strong>large keyspace is necessary but not sufficient</strong> for security!</p>
<figure>
<img src="./imgs/frequency-analysis.png" id="fig:frequency-analysis" alt="" /><figcaption>Figure 3: Comparing letter frequencies of known language with ciphertext <span class="citation" data-cites="FrequencyAnalysis2020">(“Frequency Analysis: Breaking the Code - Crypto Corner” <a href="#ref-FrequencyAnalysis2020" role="doc-biblioref">2020</a>)</span></figcaption>
</figure>
<h2 data-number="3.3" id="vigenère-cipher" data-number="3.3"><span class="header-section-number">3.3</span> Vigenère Cipher</h2>
<p>Generate a key by repeating a given key until it matches the length of the plaintext. Replace each plaintext letter by another letter using a Caesar Cipher, whose key is the number associated to the corresponding letter of the generated key. Key = a string of letters.</p>
<p>Formally, we identify <span class="math inline">\lbrace \mathtt{A, B, C, …, Z} \rbrace \cong ℤ / 26 ℤ</span>. If <span class="math inline">l</span> is the length of the key, then <span class="math inline">\mathcal{P} = \lbrace{(a_0, …,a_n) \mid a_i ∈ ℤ / 26 ℤ, n ∈ ℕ}\rbrace</span> and <span class="math display">\begin{aligned}
E_k(a_1, …, a_n) &amp;= (a_1 + k_{0 \mod l}, …, a_n + k_{n \mod l})\\
D_k(c_1, …, c_n) &amp;= (c_1 - k_{0 \mod l}, …, c_n - k_{n \mod l}).
\end{aligned}
</span> (all operations are to be understood <span class="math inline">\mod 26</span>.)</p>
<p>Vigenère Cipher is an example of <strong>polyalphabetic</strong> ciphers (each given letter can be encrypted into <span class="math inline">l</span> different letters).</p>
<p>The naive letter frequency analysis does not work, as the same letter is encrypted by different letters depending on its position.</p>
<p>If the key length is known, the Vigenère Cipher can be broken, breaking a sequence of Caesar Ciphers in strict rotation.</p>
<p>The key length can be guessed using simple analyses of the cipher text (Kasiski test, index of coincidence).</p>
<h1 data-number="4" id="computational-complexity" data-number="4"><span class="header-section-number">4</span> Computational complexity</h1>
<blockquote>
<p>Computational complexity of basic mathematical operations and of the exhaustive key search attack. Complexity classes of algorithms.</p>
</blockquote>
<h2 data-number="4.1" id="turing-machines" data-number="4.1"><span class="header-section-number">4.1</span> Turing Machines</h2>
<h3 data-number="4.1.1" id="deterministic-turing-machines" data-number="4.1.1"><span class="header-section-number">4.1.1</span> Deterministic Turing machines</h3>
<p><span class="math inline">k</span>-tape Turing machine is a triple <span class="math inline">M = (A,Q,τ)</span> satisfying:</p>
<ul>
<li><span class="math inline">A</span> is a finite <strong>alphabet</strong> that the <span class="math inline">k</span> tapes contain: <span class="math inline">A = \lbrace{\square, \vartriangleright, 0, 1}\rbrace</span>;</li>
<li><span class="math inline">Q</span> is a finite set of <strong>states</strong> that includes <span class="math inline">q_{start}, q_{halt} ∈ Q</span>;</li>
<li><span class="math inline">τ: Q × A^k → Q × A^{k−1} × \lbrace{L,S,R}\rbrace^k</span> is the <strong>transition function</strong> of <span class="math inline">M</span>.</li>
</ul>
<p><em>Tape</em> is function <span class="math inline">ℕ → A</span>.</p>
<p>First tape is <strong>input</strong> tape (read-only), second to <span class="math inline">k-1</span>-st tape are <strong>work</strong> tapes, <span class="math inline">k</span>-th tape is <strong>output</strong> tape.</p>
<p><span class="math inline">\square</span> is the <strong>blank</strong> symbol, <span class="math inline">\vartriangleright</span> is the <strong>start</strong> symbol</p>
<p><span class="math inline">q_{start}, q_{halt}</span> are the <strong>start</strong> and <strong>halting</strong> states</p>
<p>A <strong>register</strong> contains a current state</p>
<p>A <strong>tape head</strong> reads/write symbols, moves Left, Right or Stays</p>
<p>Explain these notions using fig. <a href="#fig:turing">4</a>.</p>
<figure>
<img src="./imgs/turing.png" id="fig:turing" alt="" /><figcaption>Figure 4: A Turing machine with 3 tapes <span class="citation" data-cites="Arora2009">(Arora and Barak <a href="#ref-Arora2009" role="doc-biblioref">2009</a>)</span></figcaption>
</figure>
<h3 data-number="4.1.2" id="probabilistic-turing-machine" data-number="4.1.2"><span class="header-section-number">4.1.2</span> Probabilistic Turing machine</h3>
<p>A Turing machine that may choose at every step a move at random according to a probability distribution.</p>
<p>Note that such a Turing machine is thus <strong>non-deterministic</strong>.</p>
<p>A probabilistic Turing machine <span class="math inline">M</span> computes a function <span class="math inline">f: \lbrace{0, 1}\rbrace^* → \lbrace{0, 1}\rbrace^*</span> if <span class="math display">P[f(x) = M(x)] ≥ ⅔
</span></p>
<h2 data-number="4.2" id="running-time" data-number="4.2"><span class="header-section-number">4.2</span> Running time</h2>
<p><span class="math inline">M</span> computes <span class="math inline">f: \lbrace{0, 1}\rbrace^* → \lbrace{0, 1}\rbrace^*</span> in <span class="math inline">T(n)</span>-time, if for every input <span class="math inline">x ∈ \lbrace{0, 1}\rbrace^*</span>, <span class="math inline">M</span> halts after at most <span class="math inline">T(|n|)</span> steps with output <span class="math inline">f(x)</span>.</p>
<h3 data-number="4.2.1" id="running-times-of-arithmetic-operations" data-number="4.2.1"><span class="header-section-number">4.2.1</span> Running times of arithmetic operations</h3>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Addition of two <span class="math inline">n</span>-bit numbers</td>
<td><span class="math inline">O(n)</span></td>
</tr>
<tr class="even">
<td>Multiplication of two <span class="math inline">n</span>-bit numbers</td>
<td><span class="math inline">O(n^2)</span></td>
</tr>
<tr class="odd">
<td>Raising a number to an <span class="math inline">n</span>-bit power</td>
<td><span class="math inline">O(n^3)</span></td>
</tr>
<tr class="even">
<td>Exhaustive key search for an <span class="math inline">n</span>-bit key</td>
<td><span class="math inline">O(2^n)</span></td>
</tr>
</tbody>
</table>
<h2 data-number="4.3" id="decidablity-and-verifiability" data-number="4.3"><span class="header-section-number">4.3</span> Decidablity and Verifiability</h2>
<h3 data-number="4.3.1" id="decidablity" data-number="4.3.1"><span class="header-section-number">4.3.1</span> Decidablity</h3>
<p>A language <span class="math inline">L ⊂ \lbrace{0, 1}\rbrace^*</span> is <strong>decidable</strong> if there exists a deterministic Turing machine computing <span class="math display">χ_{L}(x) := \begin{cases}
1 &amp; \text{if } x ∈ L \\
0 &amp; \text{if } x \not\in L
\end{cases}.
</span></p>
<h3 data-number="4.3.2" id="verifiability" data-number="4.3.2"><span class="header-section-number">4.3.2</span> Verifiability</h3>
<p>A language <span class="math inline">L ⊂ \lbrace{0, 1}\rbrace^*</span> is <strong>recursively enumerable</strong> if there exists a deterministic Turing machine computing a function <span class="math display">ν_{L}: \lbrace{0, 1}\rbrace^* \times \lbrace{0, 1}\rbrace^* →
\lbrace{0, 1}\rbrace,
</span> with the property that <span class="math display">x ∈ L \quad ⇔ \quad ∃ c ∈ \lbrace{0, 1}\rbrace^*: ν_{L}(x, c) = 1.</span> We call <span class="math inline">c</span> a <strong>certificate</strong> for <span class="math inline">x</span>.</p>
<p><strong>Note:</strong> Definiton in C2 is wrong!</p>
<h2 data-number="4.4" id="complexity-classes" data-number="4.4"><span class="header-section-number">4.4</span> Complexity classes</h2>
<p>A problem instance <span class="math inline">x</span> lies in the <strong>complexity class</strong></p>
<ul>
<li><strong><span class="math inline">P</span></strong> if <span class="math inline">x</span> is solvable by a polynomial <strong>deterministic</strong> algorithm.</li>
<li><strong><span class="math inline">BPP</span></strong> if <span class="math inline">x</span> is solvable by a polynomial <strong>probabilistic</strong> algorithm.</li>
<li><strong><span class="math inline">BQP</span></strong> if <span class="math inline">x</span> is solvable by a polynomial deterministic algorithm on a <strong>quantum</strong> computer.</li>
<li><strong><span class="math inline">NP</span></strong> if <span class="math inline">x</span> is <strong>verifiable</strong> by a polynomial deterministic algorithm.</li>
</ul>
<figure>
<img src="./imgs/complexities.png" id="fig:complexities" alt="" /><figcaption>Figure 5: Known relations of complexities</figcaption>
</figure>
<p>It is conjectured that <span class="math inline">P = BPP</span> and Discrte Logarithm Problem as well as Factorization do not lie in <span class="math inline">NP ∩ BPP</span>.</p>
<h1 data-number="5" id="three-types-of-security" data-number="5"><span class="header-section-number">5</span> Three types of security</h1>
<blockquote>
<p>Three types of security. Perfect secrecy: definition, examples, equivalent formulations (with proof). Perfect secrecy: Shannon’s Theorem (with proof).</p>
</blockquote>
<h2 data-number="5.1" id="types-of-security" data-number="5.1"><span class="header-section-number">5.1</span> Types of security</h2>
<ul>
<li><strong>Computational security:</strong> computational complexity is high.</li>
<li><strong>Provable security:</strong> breaking the cryptosystem would solve a problem known to be hard.</li>
<li><strong>Unconditional security:</strong> breaking is not possible even if computational resources are unlimited.</li>
</ul>
<h2 data-number="5.2" id="perfect-secrecy" data-number="5.2"><span class="header-section-number">5.2</span> Perfect secrecy</h2>
<p>A cryptosystem has <strong>perfect secrecy</strong> if seeing the ciphertext gives not extra information about the plaintext.</p>
<p>A cryptosystem with perfect secrecy is <strong>unconditionally secure</strong> against a ciphertext only attack.</p>
<p>Let <span class="math inline">(\mathcal{P, C, K, E, D})</span> be a cryptosystem and probability distributions are given on <span class="math inline">\mathcal{P}</span> and <span class="math inline">\mathcal{K}</span>:</p>
<ul>
<li><span class="math inline">Pr[\mathbf{p} = p]</span> denotes the probability that a plaintext <span class="math inline">p ∈ \mathcal{P}</span> occurs,</li>
<li><span class="math inline">Pr[\mathbf{k} = k]</span> denotes the probability that a key <span class="math inline">k ∈ \mathcal{K}</span> is chosen.</li>
</ul>
<p>Analogously, <span class="math inline">Pr[\mathbf{c} = c]</span> denotes the probability that a ciphertext <span class="math inline">c ∈ \mathcal{C}</span> is transmitted.</p>
<h3 data-number="5.2.1" id="assumptions-1" data-number="5.2.1"><span class="header-section-number">5.2.1</span> Assumptions</h3>
<ul>
<li>the key and the plaintext are independent random variables;</li>
<li>each key is used for only one encryption.</li>
</ul>
<h3 data-number="5.2.2" id="propability-distribution-on-mathcalc" data-number="5.2.2"><span class="header-section-number">5.2.2</span> Propability distribution on <span class="math inline">\mathcal{C}</span></h3>
<p>By assumption we have for all <span class="math inline">c ∈ \mathcal{C}</span> that <span class="math display">Pr[\mathbf{c} = c] = \sum_{k \text{ with } c ∈ C(k)}
Pr[\mathbf[k] = k] Pr[\mathbf{p} = D_k{c}]
</span> where <span class="math inline">C(k) := \lbrace{E_k(p) : p ∈ \mathcal{P}}\rbrace</span>. This yields <span class="math display">Pr[\mathbf{c} = c \mid \mathbf{p} = p] =
\sum_{k \text{ with } c = D_k(p)} Pr[\mathbf{k} = k]
</span> Bayes’ theorem implies (if <span class="math inline">Pr[\mathbf{c} = c] &gt; 0</span>) that <span class="math display">Pr[\mathbf{p} = p \mid \mathbf{c} = c] =
\frac{Pr[\mathbf{p} = p] \; Pr[\mathbf{c} = c \mid \mathbf{p} = p]}
     {Pr[\mathbf{c} = c]}.
</span></p>
<h3 data-number="5.2.3" id="definition" data-number="5.2.3"><span class="header-section-number">5.2.3</span> Definition</h3>
<p>A cryptosystem has <strong>perfect secrecy</strong> if <span class="math inline">Pr[\mathbf{p} = p \mid \mathbf{c} = c] = Pr[\mathbf{p} = p]</span> for all <span class="math inline">p ∈ \mathcal{P},c ∈ \mathcal{C}</span>.</p>
<h3 data-number="5.2.4" id="equivalent-formulations" data-number="5.2.4"><span class="header-section-number">5.2.4</span> Equivalent formulations</h3>
<p>TFAE:</p>
<ol type="1">
<li><span class="math inline">(\mathcal{P, C, K, E, D})</span> has perfect secrecy;</li>
<li>random variables <span class="math inline">\mathcal{p}</span> and <span class="math inline">\mathcal{c}</span> are independent;</li>
<li><span class="math inline">Pr[\mathbf{c} = c \mid \mathbf{p} = p] = Pr[\mathbf{c} = c]</span>;</li>
<li><span class="math inline">∀ p_1, p_2 ∈ \mathcal{P}: Pr[\mathbf{c} = c \mid \mathbf{p}=p_1] = Pr[\mathbf{c} = c \mid \mathbf{p}=p_2]</span></li>
</ol>
<p>The distribution of <span class="math inline">\mathcal{P}</span> is irrelevant!</p>
<p><em>Proof:</em> WLOG, we assume that <span class="math inline">Pr[\mathbf{c} = c], Pr[\mathbf{p} = p] &gt; 0</span> for all <span class="math inline">c ∈ \mathcal{C}, p ∈ \mathcal{P}</span>. Otherwise, restrict <span class="math inline">\mathcal{C}</span> or <span class="math inline">\mathcal{P}</span>.</p>
<p>(<span class="math inline">1 ⇒ 2</span>): <span class="math display">Pr[\mathbf{p} = p ∩ \mathbf{c} = c] =
Pr[\mathbf{p} = p \mid \mathbf{c} = c] Pr[\mathbf{c} = c] =
Pr[\mathbf{p} = p] Pr[\mathbf{c} = c]</span></p>
<p>(<span class="math inline">2 ⇒ 3</span>): <span class="math display">Pr[\mathbf{c} = c \mid \mathbf{p} = p] =
\frac{Pr[\mathbf{p} = p ∩ \mathbf{c} = c]}{Pr[\mathbf{p} = p]} =
\frac{Pr[\mathbf{p} = p] Pr[\mathbf{c} = c]}{Pr[\mathbf{p} = p]} =
Pr[\mathbf{c} = c]
</span></p>
<p>(<span class="math inline">3 ⇒ 4</span>): <span class="math inline">∀ c ∈ \mathcal{C}</span> and <span class="math inline">∀ p_1, p_2 ∈ \mathcal{P}</span> we have <span class="math display">Pr[\mathbf{c} = c \mid \mathbf{p}=p_1] = Pr[\mathbf{c} = c] =
Pr[\mathbf{c} = c \mid \mathbf{p}=p_2].
</span></p>
<p>(<span class="math inline">4 ⇒ 1</span>): By Bayes’ Theorem we have <span class="math display">\begin{aligned}
\frac{Pr[\mathbf{c} = c] Pr[\mathbf{p_1} = p \mid \mathbf{c} = c]}
        {Pr[\mathbf{p} = p_1]} &amp;=
        Pr[\mathbf{c} = c \mid \mathbf{p}=p_1] =\\
 &amp;= Pr[\mathbf{c} = c \mid \mathbf{p}=p_2] = \\
 &amp;= \frac{Pr[\mathbf{c} = c] Pr[\mathbf{p_2} = p \mid \mathbf{c} = c]}
         {Pr[\mathbf{p} = p_2]}
\end{aligned}
</span> Thus, there exists a constant <span class="math inline">λ ∈ ℝ</span> such that <span class="math display">Pr[\mathbf{p} = p \mid \mathbf{c} = c] = λ Pr[\mathbf{p} = p].
</span> We prove <span class="math inline">λ = 1</span> and are finished <span class="math display">\begin{aligned}
Pr[\mathbf{p} = p]  &amp;=
\sum_{c ∈ \mathcal{C}} Pr[\mathbf{p} = p \mid \mathbf{c} = c]
                       Pr[\mathbf{c} = c] =\\
  &amp;= \sum_{c ∈ \mathcal{C}} Pr[\mathbf{p} = p] Pr[\mathbf{c} = c] = \\
  &amp;= λ Pr[\mathbf{p} = p]
  \underbrace{\sum_{c ∈ \mathcal{C}} Pr[\mathbf{c} = c]}_{=1}.
\end{aligned}
</span></p>
<h3 data-number="5.2.5" id="example-one-time-pad" data-number="5.2.5"><span class="header-section-number">5.2.5</span> Example: One-time pad</h3>
<p>Let <span class="math inline">\mathcal{P = C = K} = (ℤ / 2ℤ)^n</span> and <span class="math inline">E_k(p) = k + p \mod 2</span>.</p>
<p>The key is <span class="math inline">k</span> is chosen at random and may never be reused.</p>
<p>The One-time pad has perfect secrecy as</p>
<p><span class="math display">∀ p ∈ \mathcal{P}, ∀ c ∈ \mathcal{C}: Pr[c \mid p] = \frac{1}{|\mathcal{K}|}</span></p>
<h3 data-number="5.2.6" id="shannons-theorem" data-number="5.2.6"><span class="header-section-number">5.2.6</span> Shannon’s theorem</h3>
<p>Let <span class="math inline">(\mathcal{P, C, K, E, D})</span> be a cryptosystem with <span class="math inline">|\mathcal{K}| = |\mathcal{C}| = |\mathcal{P}|</span>. Then it has perfect secrecy if and only if every key is used with equal probability <span class="math inline">1/|\mathcal{K}|</span>, and <span class="math inline">∀p ∈ \mathcal{P}, ∀c ∈ \mathcal{C}</span>, there is a unique key <span class="math inline">k ∈ \mathcal{K}</span> such that <span class="math inline">E_k(p) = c</span>.</p>
<p><em>Proof:</em> (<span class="math inline">⇒</span>): We can assume that <span class="math inline">∀p ∈ \mathcal{P}: Pr [p] &gt; 0, ∀ c ∈ \mathcal{C} Pr [c] &gt; 0</span>. We have <span class="math inline">Pr [c | p] = Pr [c] &gt; 0</span>, that is, <span class="math inline">∀ c ∈ \mathcal{C}</span> there is at least one <span class="math inline">p ∈ \mathcal{P}</span> with <span class="math inline">E_k(p) = c</span>.</p>
<p>Therefore, <span class="math inline">|\mathcal{C}| = |\lbrace{E_k(p) \mid k ∈ \mathcal{K}}\rbrace| ≤ |K|</span> and, as <span class="math inline">|\mathcal{K}| = |\mathcal{C}|</span>, there is no distinct <span class="math inline">k_1 ≠ k_2</span> with <span class="math inline">E_{k_1}(p) = E_{k_2}(p) = c</span>. That is, <span class="math inline">∀p ∈ \mathcal{P}, ∀c ∈ \mathcal{C}</span>, there is a unique key <span class="math inline">k ∈ \mathcal{K}</span> such that <span class="math inline">E_k(p)=c</span>.</p>
<p>(Analogously, <span class="math inline">|\mathcal{P}| ≤ |\mathcal{K}|</span>.)</p>
<p>Let <span class="math inline">n = |\mathcal{K}|, \mathcal{P} = \lbrace{p_1,...,p_n}\rbrace</span>, and <span class="math inline">c ∈ \mathcal{C}</span> be fixed. Let <span class="math inline">k_i ∈ \mathcal{K}</span> be so that <span class="math inline">E_{k_i} (p_i ) = c</span>. Using Bayes’ theorem: <span class="math display">Pr[p_i | c] =
\frac{Pr[c | p_i]Pr[pi]}{Pr[c]} = \frac{Pr[k_i]Pr[p_i]}{Pr[c]}. </span></p>
<p>Perfect secrecy implies that <span class="math inline">∀ i: Pr[k_i] = Pr[c]</span>, all keys are used with equal probability. Since there are <span class="math inline">|\mathcal{K}|</span> keys, the probability is <span class="math inline">1/|\mathcal{K}|</span>.</p>
<p>(<span class="math inline">⇐</span>) <span class="math inline">∀ p ∈ \mathcal{P}</span>, <span class="math inline">∀ c ∈ \mathcal{C}: Pr[c|p]=1/|K|</span>, hence, we conclude by the Proposition.</p>
<h1 data-number="6" id="sec:rsa" data-number="6"><span class="header-section-number">6</span> RSA cryptosystem</h1>
<blockquote>
<p>RSA cryptosystem: definition, examples, correctness (encryption and decryption are inverse operations). Parameter generation, its complexity. Main attacks.</p>
</blockquote>
<h1 data-number="7" id="one-way-functions" data-number="7"><span class="header-section-number">7</span> One-way functions</h1>
<blockquote>
<p>One-way function, with trapdoor. Theorem: RSA keys vs Factoring (formulation and sketch of proof).</p>
</blockquote>
<h1 data-number="8" id="hash-functions" data-number="8"><span class="header-section-number">8</span> Hash functions</h1>
<blockquote>
<p>Hash function: definition, types of resistance, (non)-examples. Optimal asymmetric encryption padding.</p>
</blockquote>
<h1 data-number="9" id="discrete-logarithm-problem" data-number="9"><span class="header-section-number">9</span> Discrete logarithm problem</h1>
<blockquote>
<p>Discrete logarithm problem. The DLP assumption. The DLP in (Z/(p-1)Z, +) Is breaking the ECC cryptosystem equivalent to solving the DLP?</p>
</blockquote>
<h1 data-number="10" id="elgamal-cryptosystem" data-number="10"><span class="header-section-number">10</span> ElGamal cryptosystem</h1>
<blockquote>
<p>ElGamal cryptosystem and parameter generation: definition, correctness (encryption and decryption are inverse operations). Theorem: ElGamal keys versus DLP (with proof).</p>
</blockquote>
<h1 data-number="11" id="elliptic-curves" data-number="11"><span class="header-section-number">11</span> Elliptic curves</h1>
<blockquote>
<p>Elliptic curve: definition, singularities, normal forms, tangents. Theorem: intersection of E with a projective line (with proof).</p>
</blockquote>
<h1 data-number="12" id="group-structure-on-elliptic-curves" data-number="12"><span class="header-section-number">12</span> Group structure on elliptic curves</h1>
<blockquote>
<p>Group structure on the elliptic curve over the algebraic closure, geometrically: definition and theorem (with proof).</p>
</blockquote>
<h1 data-number="13" id="cayley-bacharachs-theorem" data-number="13"><span class="header-section-number">13</span> Cayley-Bacharach’s theorem</h1>
<blockquote>
<p>Cayley-Bacharach’s theorem (with proof).</p>
</blockquote>
<h1 data-number="14" id="associativity" data-number="14"><span class="header-section-number">14</span> Associativity</h1>
<blockquote>
<p>Associativity (sketch of proof).</p>
</blockquote>
<h1 data-number="15" id="elliptic-curves-over-finite-fields" data-number="15"><span class="header-section-number">15</span> Elliptic curves over finite fields</h1>
<blockquote>
<p>Elliptic curves over finite fields: theorems (without proof) and examples. Check that for a prime q, each natural number in the Hasse interval occurs as the order of the el@liptic curve group over the field of q elements.</p>
</blockquote>
<h1 data-number="16" id="diffie-hellman-key-agreement-protocol" data-number="16"><span class="header-section-number">16</span> Diffie-Hellman key agreement protocol</h1>
<blockquote>
<p>Diffie-Hellman key agreement: protocol, attacks. The DHP problem. The ECDHE.</p>
</blockquote>
<h1 data-number="17" id="digital-signature-scheme" data-number="17"><span class="header-section-number">17</span> Digital signature scheme</h1>
<blockquote>
<p>Digital Signature Scheme. RSA signature algorithm. Attacks: definitions and examples.</p>
</blockquote>
<p>To ensure the <strong>non-repudiation</strong> of data</p>
<h2 data-number="17.1" id="definition-1" data-number="17.1"><span class="header-section-number">17.1</span> Definition</h2>
<p><strong>Signature scheme</strong> is a <span class="math inline">5</span>-tuple <span class="math inline">(\mathcal{P , A, K, S , V})</span>, satisfying:</p>
<ul>
<li><span class="math inline">\mathcal{P}</span> is a finite set of possible <strong>messages</strong>;</li>
<li><span class="math inline">\mathcal{A}</span> is a finite set of possible <strong>signatures</strong>;</li>
<li><span class="math inline">\mathcal{K}</span>, the keyspace, is a finite set of possible <strong>keys</strong>;</li>
<li><span class="math inline">\mathcal{S} = \lbrace{sig_k : k ∈ \mathcal{K}}\rbrace</span> consists of polynomial signing algorithms <span class="math inline">sig_k : \mathcal{P → A}</span>;</li>
<li><span class="math inline">\mathcal{V} = \lbrace{ver_k : k ∈ \mathcal{K}}\rbrace</span> consists of polynomial verification algorithms <span class="math inline">ver_k : \mathcal{P × A} → \lbrace\mathtt{true, false}\rbrace</span>; <span class="math display">∀x ∈ \mathcal{P}, ∀y ∈ A: ver_k (x, y) =
  \begin{cases}
  \mathtt{true},   &amp; \text{if } y = sig_k(x)\\
  \mathtt{false},  &amp; \text{otherwise}
  \end{cases}</span></li>
</ul>
<p>A pair <span class="math inline">(x,y)</span> with <span class="math inline">x ∈ \mathcal{P}</span>, <span class="math inline">y ∈ \mathcal{A}</span> is called a <strong>signed message</strong>.</p>
<h2 data-number="17.2" id="rsa-signature-algorithm" data-number="17.2"><span class="header-section-number">17.2</span> RSA signature algorithm</h2>
<table>
<thead>
<tr class="header">
<th>Public-key cryptosystem</th>
<th>Digital Signature</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Encrypt with <span class="math inline">E_k</span></td>
<td>Sign with <span class="math inline">D_k</span></td>
</tr>
<tr class="even">
<td>Decrypt with <span class="math inline">D_k</span></td>
<td>Verify with <span class="math inline">E_k</span></td>
</tr>
</tbody>
</table>
<p><strong>RSA signature scheme</strong> is a <span class="math inline">5</span>-tuple <span class="math inline">(\mathcal{P , A, K, S , V})</span> such that:</p>
<ul>
<li><p><span class="math inline">n = pq</span>, where <span class="math inline">p, q</span> are primes,</p></li>
<li><p><span class="math inline">\mathcal{P = A} = ℤ/nℤ</span>, and</p></li>
<li><p><span class="math inline">\mathcal{K} = \lbrace{(n,p,q,d,e) : de = 1 \mod ϕ(n)}\rbrace</span></p></li>
<li><p>For <span class="math inline">k = (n,p,q,d,e)</span>, we define <span class="math display">sigk(x)=x^d \mod n \quad \text{and}</span> <span class="math display">ver_k (x, y) =
  \begin{cases}
  \mathtt{true},   &amp; \text{if } x = y^e \mod n\\
  \mathtt{false},  &amp; \text{otherwise}.
  \end{cases}</span></p></li>
<li><p>Public-key is <strong><span class="math inline">(n, e)</span></strong> and private-key is <strong><span class="math inline">(p, q, d)</span></strong>.</p></li>
</ul>
<p><strong>Note:</strong> By the defintion of DSS we should have:</p>
<p><span class="math display">\begin{aligned}
ver_k(x, y) = \mathtt{true} &amp; ⇔ y = sig_k(x) = x^d \mod n\\
&amp; ⇔ x = y^e \mod n
\end{aligned}</span></p>
<p>Since <span class="math inline">de = 1 \mod ϕ(n)</span>, we have <span class="math inline">de = tϕ(n) + 1</span> for some <span class="math inline">t ∈ ℤ</span>. If <span class="math inline">x ∈ (ℤ / nℤ)^*</span>, then <span class="math display">\begin{aligned}
(x^e)^d &amp;= x^{t ϕ(n) + 1} \mod n = (x^{ϕ(n)})^t x \mod n =\\
&amp; \underset{|(ℤ / nℤ)^*| = ϕ(n)}{=} 1^t x \mod n = x \mod n
\end{aligned}</span></p>
<p>If <span class="math inline">x \not\in (ℤ / nℤ)^*</span>, we know that <span class="math inline">x \equiv 0 \mod p</span> or <span class="math inline">x \equiv 0 \mod q</span> and uses Fermat’s little theorem and the Chinese remainder theorem as in sec. <a href="#sec:rsa">6</a>.</p>
<h2 data-number="17.3" id="attacks-on-dss" data-number="17.3"><span class="header-section-number">17.3</span> Attacks on DSS</h2>
<ul>
<li><strong>Key-only:</strong> The attacker knows the public verification key, hence, verk .</li>
<li><strong>Known message:</strong> The attacker knows some messages (not selected by him) and their signatures.</li>
<li><strong>Chosen message:</strong> The attacker knows some messages (selected by him) and their signatures.</li>
</ul>
<h2 data-number="17.4" id="goals-of-attacks-on-dss" data-number="17.4"><span class="header-section-number">17.4</span> Goals of attacks on DSS</h2>
<ul>
<li><strong>Total break:</strong> The attacker determines Alice’s private key, hence, <span class="math inline">sig_k</span>.</li>
<li><strong>Selective forgery:</strong> With a non-negligible probability, the attacker creates a valid signature on a message chosen by someone else.</li>
<li><strong>Existential forgery:</strong> Forge a signature for some message (without the ability to do this for any message).</li>
<li><strong>Universal forgery:</strong> Forge signatures of any message.</li>
</ul>
<h2 data-number="17.5" id="examples-of-attacks" data-number="17.5"><span class="header-section-number">17.5</span> Examples of attacks</h2>
<ol type="1">
<li><p><em>Existential forgery using key-only attack</em> is always possible: Choose an arbitrary signature <span class="math inline">y</span>, then compute the message <span class="math inline">x</span> given by <span class="math inline">x := E_k (y)</span>.<br />
<span class="math inline">⇒</span> use <strong>redundancy</strong> or <strong>hashing</strong>.</p></li>
<li><p><em>Universal forgery under a chosen message attack</em> is possible, if one-way function with trapdoor is multiplicative (e.g. RSA <span class="math inline">(xy)^e = x^e \cdot y^e</span>). To sign <span class="math inline">x = x_1 x_2</span> trick Alice into signing <span class="math inline">x_1, x_2</span> to obtain <span class="math inline">y_1, y_2</span> and compute <span class="math inline">(x, y) = (x, y_1 y_2)</span>.</p></li>
</ol>
<h1 data-number="18" id="sec:dss-with-hashing" data-number="18"><span class="header-section-number">18</span> DSS with hashing</h1>
<blockquote>
<p>DSS with hashing. Hash functions from block ciphers: definition and example, with proof (the example where <span class="math inline">(x, y) → a^x b^y</span>).</p>
</blockquote>
<p><em>DSS + Hashing = Hash-then-sign</em></p>
<h2 data-number="18.1" id="definition-2" data-number="18.1"><span class="header-section-number">18.1</span> Definition</h2>
<p><strong>DSS with hashing</strong> is a DSS <span class="math inline">5</span>-tuple <span class="math inline">(\mathcal{P , A, K, S , V})</span> such that:</p>
<ul>
<li><span class="math inline">\mathcal{P} = \lbrace{0,1}\rbrace^∗</span> and</li>
<li><span class="math inline">\mathcal{A} = \lbrace{0, 1}\rbrace^l</span> for some <span class="math inline">l ∈ N</span>;</li>
<li><span class="math inline">h: \mathcal{P → A}</span> a public <strong>hash function</strong> given by a polynomial algorithm;</li>
<li><span class="math inline">sig_k(x) = f_k^{−1}(h(x))</span>, where <span class="math inline">f_k : A → A</span> is a one-way function with trapdoor.</li>
<li><span class="math inline">∀x ∈ P, ∀y ∈ A: ver_k (x, y) = \begin{cases} \mathtt{true}, &amp; \text{if } f_k(y) = h(x)\\ \mathtt{false}, &amp; \text{otherwise}. \end{cases}</span></li>
</ul>
<p>To avoid the attacks <span class="math inline">h</span> must be a one-way <strong>non-multiplicative</strong> function. <span class="math inline">h</span> is <strong>collision resistant</strong> if it is infeasible to find <span class="math inline">x_1 ≠ x_2</span> with <span class="math inline">h(x_1) = h(x_2)</span>.</p>
<p>A <strong>block cipher</strong> encodes blocks of bits at a time (e.g. Vigenère, Feistel).</p>
<h2 data-number="18.2" id="definition-3" data-number="18.2"><span class="header-section-number">18.2</span> Definition</h2>
<p><strong>Hash functions from block ciphers:</strong></p>
<p>Let <span class="math inline">\mathcal{P = K = C} = \lbrace{0, 1}\rbrace^l</span> for some <span class="math inline">l ∈ ℕ</span> and <span class="math inline">E</span> be a block cipher: <span class="math display">E : \mathcal{P × K → C}, \quad (x, e) ↦ E_e(x).</span></p>
<p>Define <span class="math inline">h(x_1,...,x_r) ∈ \lbrace{0,1}\rbrace^l</span> with <span class="math inline">x_i ∈ \lbrace{0,1}\rbrace^l</span> recursively (on <span class="math inline">r</span>), by <span class="math inline">h(∅) = 0</span>, and <span class="math display">h(x_1,...,x_r) = E_{e_h}(x_r) + e_h,
\text{where } e_h = h(x_1,...,x_{r−1}).</span></p>
<p>SHA-1 is an example of such a hash function.</p>
<h1 data-number="19" id="dss-and-public-key-cryptosystems" data-number="19"><span class="header-section-number">19</span> DSS and Public-key cryptosystems</h1>
<blockquote>
<p>DSS and Public-key cryptosystem: sign-then-encrypt versus encrypt-versus-sign.</p>
</blockquote>
<h2 data-number="19.1" id="problem" data-number="19.1"><span class="header-section-number">19.1</span> Problem</h2>
<blockquote>
<p>The use of symmetric keys involves an implicit indication of the originator and intended recipient of a message. By their very nature, this is not the case for use of public keys. — <span class="citation" data-cites="Martin2012">(Martin <a href="#ref-Martin2012" role="doc-biblioref">2012</a>, 244)</span></p>
</blockquote>
<h2 data-number="19.2" id="sign-then-encrypt" data-number="19.2"><span class="header-section-number">19.2</span> Sign-then-encrypt</h2>
<h3 data-number="19.2.1" id="algorithm" data-number="19.2.1"><span class="header-section-number">19.2.1</span> Algorithm</h3>
<ol type="1">
<li>Given <span class="math inline">x ∈ \mathcal{P}</span>, Alice computes her signature <span class="math inline">y = sig_{d_{Alice}}(x)</span>.</li>
<li>She encrypts both <span class="math inline">x</span> and y using Bob’s public key <span class="math inline">z = E_{e_{Bob}}(x , y)</span>.</li>
<li>She sends <span class="math inline">z</span> to Bob, who decrypts it <span class="math inline">D_{d_{Bob}}(z) = (x, y)</span>.</li>
<li>He uses her public verification function to check whether <span class="math inline">ver_{e_{Alice}} (x , y) = \mathtt{true}</span>.</li>
</ol>
<h3 data-number="19.2.2" id="attack" data-number="19.2.2"><span class="header-section-number">19.2.2</span> Attack</h3>
<p>Bob can forward messages form Alice to Charlie pretending that Alice wrote them directly.</p>
<ol type="1">
<li>Alice sends Bob a signed and encrypted Message <span class="math inline">z</span>.</li>
<li>Bob decrypts the message and recovers the signature <span class="math inline">D_{d_{Bob}}(z) = (x, y)</span>.</li>
<li>Bob encrypts the message and the signature using Charlie’s public key <span class="math inline">\tilde{z} = E_{e_{Charlie}}(x , y)</span></li>
<li>Bob sends the message to Charlie, who decrypts it and verifies Alice’s signature <span class="math inline">ver_{e_{Alice}} (x , y) = \mathtt{true}</span>.</li>
</ol>
<p>Charlie thinks</p>
<ul>
<li>that Alice was the origin of the data and (<strong>true</strong>)</li>
<li>that nobody except Alice knows the content of the message (<strong>false</strong>)</li>
</ul>
<h2 data-number="19.3" id="solution" data-number="19.3"><span class="header-section-number">19.3</span> Solution</h2>
<p>Include the receiver’s identity in the signed data.</p>
<h2 data-number="19.4" id="encrypt-then-sign" data-number="19.4"><span class="header-section-number">19.4</span> Encrypt-then-sign</h2>
<h3 data-number="19.4.1" id="algorithm-1" data-number="19.4.1"><span class="header-section-number">19.4.1</span> Algorithm</h3>
<ol type="1">
<li>Alice encrypts the plaintext using Bob’s public key <span class="math inline">c = E_{e_{Bob}}(x)</span></li>
<li>She then signs the ciphertext <span class="math inline">y = sig_{d_{Alice}}(c)</span>.</li>
<li>She sends both <span class="math inline">c</span> and <span class="math inline">y</span> to Bob, who decrypts the ciphertext <span class="math inline">D_{d_{Bob}}(c) = (x)</span>.</li>
<li>He uses her public verification function to check whether <span class="math inline">ver_{e_{Alice}} (x , y) = \mathtt{true}</span>.</li>
</ol>
<h2 data-number="19.5" id="attack-1" data-number="19.5"><span class="header-section-number">19.5</span> Attack</h2>
<p>Charlie can intercept the message from Alice to Bob and pretend the message came from him.</p>
<ol type="1">
<li>Charlie intercepts the message form Alice to Bob and signs the ciphertext <span class="math inline">\tilde{y} = sig_{d_{Charlie}}(c)</span></li>
<li>Charlie sends both <span class="math inline">c</span> and <span class="math inline">\tilde{y}</span> to Bob, who decrypts the ciphertext <span class="math inline">D_{d_{Bob}}(c) = (x)</span>.</li>
<li>Bob uses Charlie’s public verification function to check whether <span class="math inline">ver_{e_{Charlie}} (x , y) = \mathtt{true}</span>.</li>
</ol>
<p>Bob thinks</p>
<ul>
<li>that Charlie was the origin of the data and (<strong>false</strong>)</li>
<li>that nobody except Charlie knows the content of the message. (<strong>false</strong>)</li>
</ul>
<h2 data-number="19.6" id="solution-1" data-number="19.6"><span class="header-section-number">19.6</span> Solution</h2>
<p>Include the sender’s identity in the encrypted data.</p>
<h1 data-number="20" id="elgamal-variant-of-dss-definition" data-number="20"><span class="header-section-number">20</span> ElGamal variant of DSS (Definition)</h1>
<blockquote>
<p>ElGamal variant of DSS: definition and correctness. Security assumptions. Example of misuse (with proof).</p>
</blockquote>
<h2 data-number="20.1" id="definition-4" data-number="20.1"><span class="header-section-number">20.1</span> Definition</h2>
<ul>
<li><p>Let <span class="math inline">p</span> be a prime and <span class="math inline">g</span> a primitive element <span class="math inline">\mod p</span>.</p></li>
<li><p>Let <span class="math inline">\mathcal{P} = (ℤ / pℤ)^*, \mathcal{A} = (ℤ / pℤ)^* × (ℤ / (p − 1)ℤ)</span> and define <span class="math display">\mathcal{K} = \lbrace{(p, g, d, y) : y = g^d \mod p}\rbrace.</span></p></li>
<li><p>For <span class="math inline">k = (p,g,d,y)</span>, and for a secrete random <span class="math inline">r ∈ (ℤ / (p−1)ℤ)^*</span>, define <span class="math display">sig_k(x; r) = (y1,y2),</span> where <span class="math display">y_1 = g^r \mod p, \quad \text{and} \quad
y_2 = (x − d y_1) r^{−1} \mod p−1.</span> For <span class="math inline">x, y_1 ∈ (ℤ / pℤ)^*</span> and <span class="math inline">y_2 ∈ ℤ / (p−1)ℤ</span>, define <span class="math display">ver_k(x, (y_1, y_2)) = \mathtt{true} ⇔ y^{y_1}(y_1)^{y_2} ≡ g^x \mod p</span></p></li>
<li><p>Public key is <strong><span class="math inline">(p, g, y)</span></strong> and private key is <strong><span class="math inline">d</span></strong>.</p></li>
</ul>
<h2 data-number="20.2" id="correctness" data-number="20.2"><span class="header-section-number">20.2</span> Correctness</h2>
<p>We have to prove that <span class="math display">ver_k(x, sig_k(x; r)) = \mathtt{true}
</span> for all <span class="math inline">k ∈ \mathcal{K}</span>, all <span class="math inline">x ∈ \mathcal{P}</span>, and all <span class="math inline">r ∈ (ℤ / (p−1)ℤ)^*</span>. Thus, <span id="eq:elgamal"><span class="math display">y^{y_1} (y_1)^{y_2} ≡ (g^d)^{y_1}g^{r y_2}\qquad(1)</span></span></p>
<p>Since <span class="math inline">g</span> is primitive <span class="math inline">\mod p</span> it has order <span class="math inline">p - 1</span>. Therefore, <span class="math display">g^{y_2} ≡ g^{(x - d y_1) r^{-1}} \mod p,</span> since <span class="math display">y_2 ≡ (x - d y_1) r^{-1} \mod p-1.</span></p>
<p>Plugging this into the RHS of eq. <a href="#eq:elgamal">1</a> yields <span class="math display">y^{y_1} (y_1)^{y_2} ≡ g^{d y_1}g^{r (x - d y_1) r^{-1}} ≡ g^x \mod p</span> as claimed.</p>
<h2 data-number="20.3" id="security-assumptions" data-number="20.3"><span class="header-section-number">20.3</span> Security assumptions</h2>
<ol type="1">
<li><p>Approach: Choose arbitrary <span class="math inline">y_1 ∈ (ℤ / pℤ)^*</span> and try to find <span class="math inline">y_2 ∈ (ℤ / (p - 1) ℤ)</span>. To do this one needs to solve <span class="math display">y_2 ≡ \log_{y_1} g^x y^{-y_1} \mod p,</span> i.e. one solves the DLP in <span class="math inline">(ℤ / pℤ)^*</span>.</p></li>
<li><p>Approach: Choose arbitrary <span class="math inline">y_2 ∈ (ℤ / (p - 1) ℤ)</span> and try to find <span class="math inline">y_1 ∈ (ℤ / pℤ)^*</span>. To do this one needs to solve <span class="math display">y^{y_1}(y_1)^{y_2} \equiv g^x \mod p.</span></p></li>
</ol>
<p><strong>Assumption:</strong> Both problems do not lie in BPP.</p>
<h2 data-number="20.4" id="example-of-misuse" data-number="20.4"><span class="header-section-number">20.4</span> Example of misuse</h2>
<p>If the same <span class="math inline">k</span> is used twice a total break is possible.</p>
<p><em>Proof:</em> Let <span class="math inline">(y_1, y_2)</span> a signature of <span class="math inline">x_1</span> and <span class="math inline">(y_1, z_2)</span> a signature of <span class="math inline">x_2</span>. Then <span class="math display">y^{y1} (y_1)^{y_2} ≡ g^{x_1} \mod p, \quad
  y^{y1} (y_1)^{z_2} ≡ g^{x_2} \mod p,</span> thus, <span class="math display">g^{x_1 − x_2} ≡ (y_1)^{y_2 − z_2)} mod p.</span></p>
<p>Substituting <span class="math inline">y_1 \equiv g^r \mod p</span> yields an equation in the single <strong>unknown <span class="math inline">r</span></strong>. By Fermat’s little theorem this is equivalent to <span id="eq:elgamal-misuse"><span class="math display">x_1 - x_2 \equiv r (y_2 - z_2) \mod p - 1.\qquad(2)</span></span></p>
<p>If <span class="math inline">(y_2 - z_2)</span> is invertible <span class="math inline">\mod p - 1</span>, we divide by <span class="math inline">(y_2 - z_2)</span> and are done. Otherwise, set <span class="math inline">s := \gcd(y_2 - z-2, p - 1)</span> and note that <span class="math inline">s \mid x_1 - x_2</span>. We set <span class="math display">x&#39; := \frac{x_1 - x_2}{s}, \quad
y&#39; := \frac{y_2 - z_2}{s}, \quad p&#39; := \frac{p - 1}{s}.
</span> Then eq. <a href="#eq:elgamal-misuse">2</a> becomes <span class="math display">x&#39; \equiv r y&#39; \mod p&#39;.</span> Since <span class="math inline">\gcd(y&#39;, p&#39;) = 1</span>, we obtain <span class="math inline">r \equiv x&#39; (y&#39;)^{-1} \mod p&#39;</span>.</p>
<p>This yields <span class="math inline">s</span> possible values for <span class="math inline">r \mod p - 1</span>, namely <span class="math display">r_i := x&#39;(y&#39;)^{-1} + i p&#39; \mod p − 1, \text{ for } 0 ≤ i ≤ s − 1.</span> The correct value is obtained by testing <span class="math display">y_1 \equiv g^{r_i} \mod p.</span></p>
<p>To determine the private key <span class="math inline">d</span>, we modify the defining equation for <span class="math inline">y_2</span> and obtain <span class="math display">d y_1 \equiv x - r y_2 \mod p - 1.</span> If <span class="math inline">y_1</span> is invertible <span class="math inline">\mod p -1</span> we divide by <span class="math inline">y_1</span>, otherwise we proceed as above.</p>
<h1 data-number="21" id="elgamal-and-ecdsa-variants-of-dss" data-number="21"><span class="header-section-number">21</span> ElGamal and ECDSA variants of DSS</h1>
<blockquote>
<p>ElGamal variant of DSS: example of misuse (with proof). ECDSA: definition and correctness.</p>
</blockquote>
<h2 data-number="21.1" id="definition-5" data-number="21.1"><span class="header-section-number">21.1</span> Definition</h2>
<ul>
<li><p>Let <span class="math inline">p</span> be a prime and <span class="math inline">g</span> a primitive element <span class="math inline">\mod p</span>.</p></li>
<li><p>Let <span class="math inline">\mathcal{P} = (ℤ / pℤ)^*, \mathcal{A} = (ℤ / pℤ)^* × (ℤ / (p − 1)ℤ)</span> and define <span class="math display">\mathcal{K} = \lbrace{(p, g, d, y) : y = g^d \mod p}\rbrace.</span></p></li>
<li><p>For <span class="math inline">k = (p,g,d,y)</span>, and for a secrete random <span class="math inline">r ∈ (ℤ / (p−1)ℤ)^*</span>, define <span class="math display">sig_k(x; r) = (y1,y2),</span> where <span class="math display">y_1 = g^r \mod p, \quad \text{and} \quad
y_2 = (x − d y_1) r^{−1} \mod p−1.</span> For <span class="math inline">x, y_1 ∈ (ℤ / pℤ)^*</span> and <span class="math inline">y_2 ∈ ℤ / (p−1)ℤ</span>, define <span class="math display">ver_k(x, (y_1, y_2)) = \mathtt{true} ⇔ y^{y_1}(y_1)^{y_2} ≡ g^x \mod p</span></p></li>
<li><p>Public key is <strong><span class="math inline">(p, g, y)</span></strong> and private key is <strong><span class="math inline">d</span></strong>.</p></li>
</ul>
<h2 data-number="21.2" id="example-of-misuse-1" data-number="21.2"><span class="header-section-number">21.2</span> Example of misuse</h2>
<p>If the same <span class="math inline">k</span> is used twice a total break is possible.</p>
<p><em>Proof:</em> Let <span class="math inline">(y_1, y_2)</span> a signature of <span class="math inline">x_1</span> and <span class="math inline">(y_1, z_2)</span> a signature of <span class="math inline">x_2</span>. Then <span class="math display">y^{y1} (y_1)^{y_2} ≡ g^{x_1} \mod p, \quad
  y^{y1} (y_1)^{z_2} ≡ g^{x_2} \mod p,</span> thus, <span class="math display">g^{x_1 − x_2} ≡ (y_1)^{y_2 − z_2)} mod p.</span></p>
<p>Substituting <span class="math inline">y_1 \equiv g^r \mod p</span> yields an equation in the single <strong>unknown <span class="math inline">r</span></strong>. By Fermat’s little theorem this is equivalent to <span id="eq:elgamal-misuse2"><span class="math display">x_1 - x_2 \equiv r (y_2 - z_2) \mod p - 1.\qquad(3)</span></span></p>
<p>If <span class="math inline">(y_2 - z_2)</span> is invertible <span class="math inline">\mod p - 1</span>, we divide by <span class="math inline">(y_2 - z_2)</span> and are done. Otherwise, set <span class="math inline">s := \gcd(y_2 - z-2, p - 1)</span> and note that <span class="math inline">s \mid x_1 - x_2</span>. We set <span class="math display">x&#39; := \frac{x_1 - x_2}{s}, \quad
y&#39; := \frac{y_2 - z_2}{s}, \quad p&#39; := \frac{p - 1}{s}.
</span> Then eq. <a href="#eq:elgamal-misuse2">3</a> becomes <span class="math display">x&#39; \equiv r y&#39; \mod p&#39;.</span> Since <span class="math inline">\gcd(y&#39;, p&#39;) = 1</span>, we obtain <span class="math inline">r \equiv x&#39; (y&#39;)^{-1} \mod p&#39;</span>.</p>
<p>This yields <span class="math inline">s</span> possible values for <span class="math inline">r \mod p - 1</span>, namely <span class="math display">r_i := x&#39;(y&#39;)^{-1} + i p&#39; \mod p − 1, \text{ for } 0 ≤ i ≤ s − 1.</span> The correct value is obtained by testing <span class="math display">y_1 \equiv g^{r_i} \mod p.</span></p>
<p>To determine the private key <span class="math inline">d</span>, we modify the defining equation for <span class="math inline">y_2</span> and obtain <span class="math display">d y_1 \equiv x - r y_2 \mod p - 1.</span> If <span class="math inline">y_1</span> is invertible <span class="math inline">\mod p -1</span> we divide by <span class="math inline">y_1</span>, otherwise we proceed as above.</p>
<h2 data-number="21.3" id="definition-ecdsa-hash-and-sign" data-number="21.3"><span class="header-section-number">21.3</span> Definition: ECDSA, hash-and-sign</h2>
<ul>
<li><span class="math inline">p</span> prime, <span class="math inline">\mathbf{k} = (ℤ / pℤ)</span>, <span class="math inline">E = E(\mathbf{k})</span>, <span class="math inline">P ∈ E</span> of prime order <span class="math inline">q</span>.</li>
<li><span class="math inline">\mathcal{P} = \lbrace{0, 1}\rbrace^∗, \mathcal{A} = (ℤ/qℤ)^* × (ℤ/qℤ)^*</span> and <span class="math display">\mathcal{K} = \lbrace{(p, q, E, P, d, Q) : Q = dP}\rbrace,</span> where <span class="math inline">0 ≤ d ≤ q - 1</span>.</li>
<li>For <span class="math inline">k = (p, q, E, P, d Q)</span> and a secret random <span class="math inline">r ∈ \lbrace 1, …, q-1\rbrace</span>, define <span class="math display">sig_{k}(x, r) = (t, s)</span> where <span class="math inline">rP = (u, v)</span> and <span class="math display">\begin{aligned}
t &amp;= u \mod q, \\
s &amp;= r^{-1}(h(x) + dt) \mod q.
\end{aligned}</span></li>
<li>If either <span class="math inline">t = 0</span> or <span class="math inline">s = 0</span>, a new random value of <span class="math inline">r</span> is chosen.</li>
<li>The public key is <strong><span class="math inline">(p, q, E, P, Q)</span></strong> and the private key is <strong><span class="math inline">d</span></strong>.</li>
</ul>
<h3 data-number="21.3.1" id="verification-of-ecdsa" data-number="21.3.1"><span class="header-section-number">21.3.1</span> Verification of ECDSA</h3>
<p>For <span class="math inline">x ∈ \lbrace 0, 1\rbrace^*</span> and <span class="math inline">t, s ∈ (ℤ / qℤ)^*</span>, we compute <span class="math display">\begin{aligned}
 w &amp;= s^{-1} \mod{q} \\
 i &amp;= wh(x) \mod{q} \\
 j &amp;= wt \mod{q} \\
 (u, v) &amp;= iP + jQ
 \end{aligned}</span> and define <span class="math display">ver_{k}(x, (t, s)) = \mathtt{true} ⇔ u \mod q = t</span></p>
<p>To prove correctness, show that <span class="math inline">iP + jQ = rP</span>.</p>
<h1 data-number="22" id="digital-currency" data-number="22"><span class="header-section-number">22</span> Digital currency</h1>
<blockquote>
<p>Digital currency: definition and security requirements. Distributed ledgers. Blockchain. Security assumptions underlying the generation of the bitcoin address.</p>
</blockquote>
<h1 data-number="23" id="bitcoin-transactions" data-number="23"><span class="header-section-number">23</span> Bitcoin transactions</h1>
<blockquote>
<p>Bitcoin transaction and its verification. Merkle tree. Bitcoin mining.</p>
</blockquote>
<h1 data-number="24" id="bit-generators" data-number="24"><span class="header-section-number">24</span> Bit generators</h1>
<blockquote>
<p>Bit generator. Linear feedback shift register: definition, periods, security. RSA bit generator.</p>
</blockquote>
<h1 data-number="25" id="distinguisher-and-next-bit-predictors" data-number="25"><span class="header-section-number">25</span> Distinguisher and next bit predictors</h1>
<blockquote>
<p>Distinguisher. Next bit predictor. Yao’s theorem (sketch of proof).</p>
</blockquote>
<h1 data-number="26" id="error-correcting-codes-and-expander-graphs" data-number="26"><span class="header-section-number">26</span> Error-correcting codes and expander graphs</h1>
<blockquote>
<p>Error-correcting codes and expander graphs</p>
</blockquote>
<h1 data-number="27" id="probabilistic-pidgeonhole-principle" data-number="27"><span class="header-section-number">27</span> Probabilistic pidgeonhole principle</h1>
<blockquote>
<p>Describe the probabilistic pidgeonhole principle and explain, with examples, why it is relevant in cryptography (i.e hash functions, birthday paradox etc).</p>
</blockquote>
<h1 data-number="28" id="attacks-on-cryptosystems-relying-on-structural-weaknesses" data-number="28"><span class="header-section-number">28</span> Attacks on cryptosystems relying on structural weaknesses</h1>
<blockquote>
<p>Describe a variety of attacks that rely on structural weaknesses in respective cryptosystems (for instance, known message attacks for multiplicative systems, or weaknesses of El Gamal under weak random choices).</p>
</blockquote>
<h1 data-number="29" id="shanks-algorithm" data-number="29"><span class="header-section-number">29</span> Shanks algorithm</h1>
<blockquote>
<p>Describe Shanks algorithm, give examples of its use and outline how to use Shanks Algorithm to compute the order of an elliptic curve of prime order in combination with Hasse’s bound.</p>
</blockquote>
<h1 data-number="30" id="todo-s" data-number="30"><span class="header-section-number">30</span> TODO-s:</h1>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
Sec. <a href="#sec:dss-with-hashing">18</a>: Example where <span class="math inline">(x, y) → a^x b^y</span>.</li>
<li><input type="checkbox" disabled="" />
Sec. <a href="#sec:symmetric-cs">3</a>: If the given key of a Vigenère Cipher has repeated letters, does it make it any easier to break?</li>
</ul>
<h2 class="unnumbered" data-number="" id="references" class="unnumbered" data-number="">References</h2>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-Arora2009">
<p>Arora, Sanjeev, and Boaz Barak. 2009. <em>Computational Complexity</em>. Cambridge University Press, Cambridge. <a href="https://doi.org/10.1017/CBO9780511804090">https://doi.org/10.1017/CBO9780511804090</a>.</p>
</div>
<div id="ref-Arzhantseva2019">
<p>Arzhantseva, Goulnara. 2019. “Exam Questions.” <a href="https://www.mat.univie.ac.at/~gagt/crypto2019/ExamQuestions.pdf">https://www.mat.univie.ac.at/~gagt/crypto2019/ExamQuestions.pdf</a>.</p>
</div>
<div id="ref-CaeserCipher2020">
<p>“Caesar Cipher in Cryptography - Geeksforgeeks.” 2020. January 23, 2020. <a href="https://www.geeksforgeeks.org/caesar-cipher-in-cryptography/">https://www.geeksforgeeks.org/caesar-cipher-in-cryptography/</a>.</p>
</div>
<div id="ref-FrequencyAnalysis2020">
<p>“Frequency Analysis: Breaking the Code - Crypto Corner.” 2020. January 23, 2020. <a href="https://crypto.interactive-maths.com/frequency-analysis-breaking-the-code.html">https://crypto.interactive-maths.com/frequency-analysis-breaking-the-code.html</a>.</p>
</div>
<div id="ref-Martin2012">
<p>Martin, Keith M. 2012. <em>Everyday Cryptography: Fundamental Principles and Applications</em>. Oxford University Press.</p>
</div>
</div>
                </div>
            </div>
            <script>
                  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-156699711-1', 'auto');
  ga('send', 'pageview');
            <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>
        </div>
            </body>
</html>
